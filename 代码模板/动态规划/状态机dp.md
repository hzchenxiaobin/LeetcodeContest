**状态机 DP** 是一种动态规划的技巧，通常用于解决涉及多种状态和状态转移的问题。它非常适合于处理多阶段决策的问题，尤其是在某个时刻的决策依赖于前面多个不同状态的决策时。常见的状态机 DP 问题包括股票买卖问题、区间问题等。

### 状态机 DP 的关键点

1. **状态定义**：问题中的每个状态如何表示。每个状态可能由多个维度（如天数、操作类型等）组成。
2. **状态转移方程**：从一个状态转移到另一个状态的方式。
3. **边界条件**：初始状态和终止状态。
4. **优化目标**：通过计算每个状态的值来找到最优解。

------

### 示例：股票买卖问题（经典的状态机 DP 问题）

假设你有一个数组，表示每一天的股票价格。你可以进行一次或多次股票买卖，但你同一时间最多只能持有一股股票，如何通过交易获取最大的利润？我们可以通过状态机 DP 来解决此问题。

#### 题目：买卖股票的最佳时机 II

- 给定一个数组 `prices`，表示每一天的股票价格。你可以进行多次交易（买入和卖出），但是你同一时间最多只能持有一股股票，问你如何最大化利润？

#### 状态定义：

1. `dp[i][0]` 表示第 `i` 天结束时，**没有持有股票** 的最大利润。
2. `dp[i][1]` 表示第 `i` 天结束时，**持有股票** 的最大利润。

#### 状态转移方程：

- 第 `i` 天不持有股票的最大利润 `dp[i][0]`，可以由以下两种情况转移而来：

  1. 第 `i-1` 天也没有持有股票：`dp[i-1][0]`
  2. 第 `i-1` 天持有股票，但在第 `i` 天卖出了：`dp[i-1][1] + prices[i]`

  所以：

  ```cpp
  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
  ```

- 第 `i` 天持有股票的最大利润 `dp[i][1]`，可以由以下两种情况转移而来：

  1. 第 `i-1` 天也持有股票：`dp[i-1][1]`
  2. 第 `i-1` 天没有持有股票，但在第 `i` 天买入了：`dp[i-1][0] - prices[i]`

  所以：

  ```cpp
  dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
  ```

#### 初始状态：

- 第 0 天结束时，**不持有股票** 的最大利润 `dp[0][0] = 0` （因为没有进行任何交易）。
- 第 0 天结束时，**持有股票** 的最大利润 `dp[0][1] = -prices[0]` （因为第一天买入了股票）。

#### 结果：

我们最后的目标是求出所有交易结束时的最大利润，最终答案是 `dp[n-1][0]`，即最后一天没有持有股票的最大利润。

#### 代码实现：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;

    // 初始化 dp 数组
    std::vector<std::vector<int>> dp(n, std::vector<int>(2));

    // 初始状态
    dp[0][0] = 0;             // 第 0 天不持有股票的利润
    dp[0][1] = -prices[0];     // 第 0 天持有股票的利润

    for (int i = 1; i < n; ++i) {
        // 状态转移
        dp[i][0] = std::max(dp[i-1][0], dp[i-1][1] + prices[i]);  // 不持有股票的最大利润
        dp[i][1] = std::max(dp[i-1][1], dp[i-1][0] - prices[i]);  // 持有股票的最大利润
    }

    // 返回最后一天不持有股票的最大利润
    return dp[n-1][0];
}

int main() {
    std::vector<int> prices = {7, 1, 5, 3, 6, 4};
    std::cout << "最大利润: " << maxProfit(prices) << std::endl;
    return 0;
}
```

#### 输出结果：

```
最大利润: 7
```

#### 解释：

对于输入 `{7, 1, 5, 3, 6, 4}`，我们可以在第 2 天（价格为 1）买入，在第 3 天（价格为 5）卖出；然后在第 4 天（价格为 3）买入，在第 5 天（价格为 6）卖出，总利润为 4 + 3 = 7。

------

### 总结

**状态机 DP** 的核心是：

1. **明确状态**：问题可以分为哪些不同的状态，这些状态是怎么变化的。
2. **定义状态转移方程**：每个状态可以从前一个或多个状态转移而来。
3. **解决问题**：从初始状态开始，逐步计算到最终状态，最后得出结果。

这种方法特别适合解决具有阶段性、涉及多种决策或操作的问题，如股票买卖、区间动态规划、字符串操作等。



进阶的状态机 DP 通常用于解决更复杂的问题，其中包含多种状态、复杂的状态转移和更多的操作限制。要处理这些问题，状态机 DP 的关键是如何设计多个状态和状态转移规则，同时要优化空间复杂度和计算效率。

以下是几类常见的**进阶状态机 DP**问题，以及相关的思路：

------

### 示例 1：股票买卖问题进阶版（含交易次数限制、冷冻期和手续费）

#### 1.1 买卖股票的最佳时机 III（最多两次交易）

这是一道经典的进阶问题，允许最多进行两次交易。

#### 问题：

- 给定一个数组 `prices`，表示每一天的股票价格。你最多可以进行两次交易，问如何通过交易获取最大的利润。

#### 思路：

定义状态机，使用 DP 来表示在不同状态下的最大利润：

1. **状态定义：**
   - `dp[i][0]` 表示第 `i` 天不操作（无股票且未进行任何操作）的最大利润。
   - `dp[i][1]` 表示第 `i` 天第一次买入股票的最大利润。
   - `dp[i][2]` 表示第 `i` 天第一次卖出股票的最大利润。
   - `dp[i][3]` 表示第 `i` 天第二次买入股票的最大利润。
   - `dp[i][4]` 表示第 `i` 天第二次卖出股票的最大利润。
2. **状态转移方程：**
   - `dp[i][0] = dp[i-1][0]`：保持不操作状态。
   - `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`：选择保持第一次买入状态，或者在不操作状态买入股票。
   - `dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])`：保持第一次卖出状态，或者在第一次买入状态卖出股票。
   - `dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])`：保持第二次买入状态，或者在第一次卖出状态进行第二次买入。
   - `dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])`：保持第二次卖出状态，或者在第二次买入状态进行卖出。
3. **边界条件：** 初始时：
   - `dp[0][0] = 0`：什么都不做。
   - `dp[0][1] = -prices[0]`：买入股票。
   - `dp[0][2] = 0`：买入后再卖出。
   - `dp[0][3] = -prices[0]`：进行第二次买入。
   - `dp[0][4] = 0`：第二次卖出。
4. **代码实现：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;

    // 初始化五种状态
    std::vector<std::vector<int>> dp(n, std::vector<int>(5, 0));
    dp[0][1] = -prices[0];  // 第一次买入
    dp[0][3] = -prices[0];  // 第二次买入

    for (int i = 1; i < n; ++i) {
        dp[i][0] = dp[i-1][0];
        dp[i][1] = std::max(dp[i-1][1], dp[i-1][0] - prices[i]);
        dp[i][2] = std::max(dp[i-1][2], dp[i-1][1] + prices[i]);
        dp[i][3] = std::max(dp[i-1][3], dp[i-1][2] - prices[i]);
        dp[i][4] = std::max(dp[i-1][4], dp[i-1][3] + prices[i]);
    }

    // 返回最后一天结束时，最多两次交易的最大利润
    return dp[n-1][4];
}

int main() {
    std::vector<int> prices = {3, 3, 5, 0, 0, 3, 1, 4};
    std::cout << "最大利润: " << maxProfit(prices) << std::endl;
    return 0;
}
```

#### 解释：

1. `dp[i][1]` 和 `dp[i][3]` 表示买入状态，利润是负的，因为要减去买入的花费。
2. 通过对状态进行转移，我们考虑了每种可能的操作，最后在 `dp[n-1][4]` 中可以得到最大利润。

------

#### 1.2 买卖股票的最佳时机 IV（最多 `k` 次交易）

该问题允许最多进行 `k` 次交易，解决思路与最多两次交易类似，只不过状态的维度会变得更多。

1. **状态定义：**
   - `dp[i][j][0]` 表示第 `i` 天结束时，已经进行了 `j` 次交易且不持有股票的最大利润。
   - `dp[i][j][1]` 表示第 `i` 天结束时，已经进行了 `j` 次交易且持有股票的最大利润。
2. **状态转移方程：**
   - `dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])`：不操作，或者卖出股票。
   - `dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])`：保持持有股票，或者在完成 `j-1` 次交易后买入股票。
3. **初始状态：**
   - `dp[0][0][0] = 0`：初始时没有交易，且没有股票。
   - `dp[0][0][1] = -prices[0]`：初始时第一天买入。

#### 代码实现：

```cpp
int maxProfit(int k, std::vector<int>& prices) {
    int n = prices.size();
    if (n == 0 || k == 0) return 0;

    // 如果 k >= n / 2，则可以进行任意多次交易，简化为贪心问题
    if (k >= n / 2) {
        int max_profit = 0;
        for (int i = 1; i < n; ++i) {
            if (prices[i] > prices[i - 1]) {
                max_profit += prices[i] - prices[i - 1];
            }
        }
        return max_profit;
    }

    // DP 数组
    std::vector<std::vector<std::vector<int>>> dp(n, std::vector<std::vector<int>>(k + 1, std::vector<int>(2, 0)));
    
    // 初始化状态
    for (int j = 0; j <= k; ++j) {
        dp[0][j][1] = -prices[0]; // 第 0 天买入股票的代价
    }

    // 状态转移
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j <= k; ++j) {
            dp[i][j][0] = std::max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);  // 卖出
            dp[i][j][1] = std::max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]); // 买入
        }
    }

    // 返回最大利润
    return dp[n-1][k][0];
}
```

------

### 2. 状态机 DP 与其他问题结合

除了股票买卖，状态机 DP 还可以应用在其他多状态转移问题中，如：

- **字符串操作问题**：如最长回文子序列，可以将每种字符操作视为状态。
- **区间问题**：如分割、合并等，可以将每个区间的操作视为状态。

------

### 总结

进阶的状态机 DP 主要是通过增加状态的维度和更加复杂的转移方程，来应对更复杂的操作和约束。通过合理定义状态、设计状态转移方程，并结合空间优化技巧（如滚动数组），可以高效解决复杂的动态规划问题。