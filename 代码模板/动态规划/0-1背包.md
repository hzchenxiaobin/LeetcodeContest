









### 恰好装满型0-1背包

**恰好装满型 0-1 背包问题**是 0-1 背包问题的一个变种。在标准的 0-1 背包问题中，我们希望在不超过背包容量的情况下最大化价值；而在**恰好装满型 0-1 背包问题**中，除了容量限制，还要求物品必须恰好填满背包。

### 问题描述：

给定一个容量为 `C` 的背包和 `n` 个物品，每个物品有一个重量 `w[i]` 和价值 `v[i]`。要求从这些物品中选择一些物品，使得总重量恰好为 `C`，并且总价值最大。如果无法恰好装满背包，则返回 0。

### 解法思路：

这个问题的思路类似于经典的 0-1 背包问题，只是需要在最后确保背包的总重量恰好等于容量 `C`。通常，动态规划可以很好地解决这个问题。

#### 动态规划的核心思路：

1. **状态定义**：

   - 设 `dp[j]` 表示填满容量为 `j` 的背包时能够获得的最大价值。如果 `dp[j]` 为负数，表示无法恰好装满容量为 `j` 的背包。

2. **状态转移方程**：

   - 对于每个物品 

     - i如果我们选择了这个物品，其重量是 w[i]

     ，价值是 

     ```
     v[i]
     ```

     ，那么状态转移方程为：

     ```css
     dp[j] = max(dp[j], dp[j - w[i]] + v[i])
     ```

     其中 

     ```
     j
     ```

      是当前背包的容量，

     ```
     w[i]
     ```

      是物品的重量。如果不选这个物品，

     ```
     dp[j]
     ```

      不变；如果选了这个物品，新的最大价值是 

     ```
     dp[j - w[i]] + v[i]
     ```

     。

3. **初始状态**：

   - `dp[0] = 0`，表示当背包容量为 0 时，能够获得的最大价值是 0。
   - 对于其他容量，`dp[j]` 初始为负无穷，表示无法恰好装满容量为 `j` 的背包。

4. **最终结果**：

   - 最后，检查 `dp[C]` 的值。如果 `dp[C]` 为负无穷，表示无法恰好装满容量为 `C` 的背包，返回 0；否则，返回 `dp[C]`，即恰好装满容量为 `C` 时的最大价值。

------

### 代码实现：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

int knapsackExactFill(int C, const std::vector<int>& weights, const std::vector<int>& values) {
    int n = weights.size();
    // 初始化 dp 数组，dp[j] 表示恰好装满容量 j 时的最大价值
    std::vector<int> dp(C + 1, INT_MIN);
    dp[0] = 0; // 恰好装满容量 0 的最大价值为 0

    // 遍历每个物品
    for (int i = 0; i < n; ++i) {
        // 倒序遍历，确保每个物品只能被使用一次
        for (int j = C; j >= weights[i]; --j) {
            if (dp[j - weights[i]] != INT_MIN) { // 如果容量 j-w[i] 可被恰好装满
                dp[j] = std::max(dp[j], dp[j - weights[i]] + values[i]);
            }
        }
    }

    // 如果 dp[C] 仍为负无穷，表示无法恰好装满容量为 C 的背包
    return dp[C] == INT_MIN ? 0 : dp[C];
}

int main() {
    int C = 10; // 背包容量
    std::vector<int> weights = {1, 3, 4, 6}; // 物品的重量
    std::vector<int> values = {10, 40, 50, 70}; // 物品的价值

    int max_value = knapsackExactFill(C, weights, values);
    std::cout << "恰好装满容量 " << C << " 时的最大价值是: " << max_value << std::endl;

    return 0;
}
```

### 代码解释：

- `dp[j]` 代表恰好填满容量为 `j` 的背包时的最大价值。
- 对每个物品遍历，从后向前更新 `dp` 数组，确保每个物品只能使用一次。
- 最终，`dp[C]` 表示恰好装满容量为 `C` 时的最大价值。如果 `dp[C]` 为 `INT_MIN`，则说明无法恰好装满。

### 输出结果：

```
复制代码
恰好装满容量 10 时的最大价值是: 80
```

------

### 进一步的优化和总结：

1. **时间复杂度**：该算法的时间复杂度是 `O(n * C)`，其中 `n` 是物品的个数，`C` 是背包的容量。

2. **空间复杂度**：使用滚动数组优化后，空间复杂度为 `O(C)`。

3. 关键点

   ：

   - **倒序遍历**：为了避免一个物品被多次选择，必须在每次更新 `dp` 数组时倒序遍历。
   - **初始状态**：`dp[0] = 0` 表示容量为 0 的背包可以恰好装满，初始状态中其余 `dp[j]` 值为负无穷，表示这些容量无法恰好装满。

通过这种思路，可以解决更多关于“恰好装满”的变种问题。

